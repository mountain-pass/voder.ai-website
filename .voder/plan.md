## NOW
Create the non-interactive health-check script file scripts/health-check.js that implements the health-check described in the plan (Node built-ins only: fs, path, child_process, os, process). The script must:
- Print required Node version from package.json.engines and the running Node version; exit 2 if requirement unmet.
- Verify presence of package-lock.json and node_modules/; print remediation hints and exit 2 if missing.
- Run (streaming output) in sequence: npm run type-check, npm run lint:check, npm run format:check — surface console-first diagnostics for each step and summarize pass/fail, exiting non-zero on any failure.
- Use clear remediation messages (exact commands to run) and be fully non-interactive.
Commit with message:
chore: add health-check script

## NEXT
After committing the NOW change, perform the following focused changes in order. Run npm run health-check locally after the NOW step and iterate on any failures before proceeding to the next step.

1) Add package.json script entry
   - Modify package.json to add:
     "health-check": "node scripts/health-check.js"
   - Commit message: chore: add health-check script and package.json entry

2) Enforce deterministic verification pipeline order
   - Add script: "audit:fix": "npm audit fix --package-lock-only"
   - Replace existing "verify" script with the ordered, non-interactive pipeline:
     "verify": "npm run audit:fix && npm run lint:fix && npm run lint:check && npm run format:check && npm run build && npm run test:ci"
   - Commit message: chore: enforce verification pipeline order in package.json

3) Wire health-check into CI
   - Update .github/workflows/ci.yml to add a step after dependency install that runs:
     - npm ci (already present) → npm run prepare (if prepare is needed) → npm run health-check
   - Ensure the job uses non-interactive flags and fails the workflow on any non-zero exit code. Keep the step concise and console-first.
   - Commit message: ci: run health-check during CI install step

4) Add concise README instructions
   - Create README.md documenting:
     - Node requirement and recommended version-manager commands (nvm/fnm example).
     - Quickstart: npm ci, npm run prepare, npm run dev, npm run health-check, npm run verify.
     - How to interpret health-check output and remediation commands.
     - Note that docs/libraries/ is generated by prepare and is gitignored.
   - Commit message: docs: add README with quickstart and health-check instructions

5) Local validation and iteration
   - Locally run (and fix until green):
     - npm ci
     - npm run prepare
     - npm run health-check
     - npm run test
   - Address any issues surfaced by the health-check/tests with small commits, e.g.:
     - fix(test): adjust test DOM setup or imports
     - fix(health-check): handle missing package-lock.json or node_modules edge cases
     - fix(lint): remove unused imports or apply eslint --fix changes
   - Only push changes when health-check and tests pass locally.
   - Commit messages for fixes should follow the focused format (fix(...): ...).

## LATER
After NOW and NEXT are green and CI passes, implement these follow-ups (each as a focused commit):

1) Add unit tests for scripts
   - tests/prepare-libraries.test.ts: create temporary node_modules fixtures using os.tmpdir() + fs.mkdtempSync, run scripts/prepare-libraries.js against fixture, assert docs/libraries entries and cleanup.
   - tests/health-check.test.ts: unit tests that mock child_process spawn/exec behavior (using vitest mocking) to assert health-check exit codes and messages.
   - Commit message: test(scripts): add unit tests for prepare-libraries and health-check

2) CI: lockfile drift detection
   - Add CI step: run npm ci --package-lock-only and fail if git status shows changes (detect lockfile drift).
   - Commit message: ci: add lockfile drift detection

3) Reinstate check-only pre-commit hooks
   - Configure husky (or simple-git-hooks) + lint-staged to run check-only tasks on staged files:
     - eslint --max-warnings 0 (check only)
     - prettier --check (no --write)
     - stylelint --report-needless-disables / --config as appropriate
   - Ensure hooks never auto-modify code and document bypass via --no-verify.
   - Commit message: chore: add pre-commit hooks (check-only) and documentation

4) Defensive JS wrappers for TypeScript config files
   - Add minimal CJS wrappers like postcss.config.cjs and htmlhint.config.cjs that attempt to load the TS config (via jiti or require) and print clear diagnostics if loading fails.
   - Commit message: chore: add defensive JS wrappers for TS configs

5) Increase automated coverage and enforce thresholds
   - Expand Vitest tests across app and script modules, tune vitest.config.ts coverage thresholds to realistic, incremental targets, and integrate npm run test:coverage into CI.
   - Commit message: test: increase coverage and enforce thresholds

Notes / Constraints / Safety
- All scripts (health-check & wrappers) must be non-interactive and use only Node built-ins (except the deliberate CJS wrappers which may use jiti if already present in devDependencies).
- Keep commits small and focused, use the exact commit messages specified for each change.
- Do not modify prompts/, prompt-assets/, .voder/ directories (per project safety rules).
- Do not attempt to run or start servers in the plan; the plan focuses on health-check, verification pipeline, CI wiring, and tests.
- Iteratively fix issues surfaced by the health-check and tests locally before pushing changes to remote.