# DEV-GIT-HOOKS: Git Hooks for Quality Gates

## Release Goal

_"Essential Developer Experience - Quality feedback essentials for high-quality code development"_

Implement git hooks that provide immediate quality feedback during the commit process, ensuring code quality standards are maintained before changes are committed to the repository for the vibe rot problem validation website.

## How This Story Contributes

This story establishes automated quality gates that prevent low-quality code from entering the repository. Git hooks provide the final validation layer after developers have run manual quality checks, ensuring consistent code quality across all commits while maintaining developer autonomy.

## User Story

So that I can catch quality issues before they enter the repository and maintain consistent code standards across all commits, as a developer, I want git hooks that validate code quality without automatically modifying my code.

**INVEST Criteria Compliance**:

- **Independent**: Git hooks can be implemented independently after basic tooling is established
- **Negotiable**: Hook configuration and validation rules can be refined
- **Valuable**: Prevents quality issues from entering repository and maintains standards
- **Estimable**: Clear scope for implementing pre-commit validation hooks
- **Small**: Can be completed by configuring existing quality tools as git hooks
- **Testable**: Success measured by hooks running on commits and catching quality issues

## Acceptance Criteria

- [ ] **Pre-commit hooks configured** using a standard git hooks framework (e.g., husky, simple-git-hooks)
- [ ] **Quality validation pipeline** runs on pre-commit: lint check → format check → type check → tests
- [ ] **Check-only policy enforced** - hooks validate but never modify code automatically
- [ ] **Clear error messages** provided when quality checks fail with guidance on how to fix
- [ ] **Efficient execution** - hooks run only necessary checks on staged files
- [ ] **Selective file checking** - only validate files that are being committed
- [ ] **Hook bypass option** available for emergency commits with clear documentation
- [ ] **Developer documentation** explains hook behavior and how to resolve common issues
- [ ] **CI consistency** - same quality checks run in hooks and CI pipeline

## Requirements

### Git Hooks Framework

- **REQ-HOOKS-FRAMEWORK**: Use lightweight git hooks framework (simple-git-hooks or husky)
- **REQ-HOOKS-CONFIG**: Configure hooks through package.json or dedicated config file
- **REQ-HOOKS-INSTALL**: Automatic hook installation during npm install process
- **REQ-HOOKS-CROSS-PLATFORM**: Hooks work consistently across macOS, Windows, and Linux

### Quality Validation Pipeline

- **REQ-LINT-CHECK**: Run ESLint in check-only mode (no --fix)
- **REQ-FORMAT-CHECK**: Run Prettier in check-only mode (--check, no --write)
- **REQ-TYPE-CHECK**: Run TypeScript compiler in check-only mode (--noEmit)
- **REQ-TEST-AFFECTED**: Run tests for files affected by the commit
- **REQ-STAGED-FILES**: Only validate staged files, not entire codebase

### Hook Behavior Standards

- **REQ-GIT-HOOKS-CHECK-ONLY**: Git hooks MUST only perform quality checks and MUST NOT modify code
- **REQ-HOOKS-CHECK-COMMANDS**: Git hooks MUST use check-only commands (e.g., `lint:check`, not `lint:fix`)
- **REQ-HOOKS-NO-FORMAT**: Git hooks MUST use format validation but MUST NOT auto-format files
- **REQ-HOOKS-FAIL-CLEAR**: Git hooks MUST fail with clear error messages if quality checks fail
- **REQ-HOOKS-EFFICIENT**: Hooks must run efficiently, checking only staged files
- **REQ-HOOKS-INCREMENTAL**: Only check files being committed, not entire project

### Developer Experience

- **REQ-CLEAR-ERRORS**: Provide specific file and line information when validation fails
- **REQ-FIX-GUIDANCE**: Error messages include commands to fix the issues
- **REQ-BYPASS-OPTION**: Support --no-verify flag for emergency commits
- **REQ-HOOK-STATUS**: Clear indication when hooks are running and their progress
- **REQ-DOCUMENTATION**: Developer guide explaining hook behavior and common workflows

### CI Integration

- **REQ-CI-CONSISTENCY**: Same validation commands used in hooks and CI pipeline
- **REQ-CI-REDUNDANCY**: CI pipeline validates even if hooks are bypassed
- **REQ-HOOK-OPTIONAL**: Project builds successfully even if hooks are disabled
- **REQ-HOOK-VERSION**: Hook configuration versioned with project code

## Dependencies

- 006.0-DEV-FORMAT (requires Prettier configuration)
- 010.0-DEV-LINT-JS (requires ESLint configuration)
- 004.0-DEV-TYPESCRIPT (requires TypeScript configuration)
- 011.0-DEV-TEST-UNIT (requires testing framework)

## Technical Implementation Notes

### Hook Configuration Example

```json
{
  "simple-git-hooks": {
    "pre-commit": "npm run pre-commit"
  },
  "scripts": {
    "pre-commit": "npm run lint:check && npm run format:check && npm run type:check && npm run test:staged"
  }
}
```

### Validation Commands

- `npm run lint:check` - ESLint with --max-warnings 0
- `npm run format:check` - Prettier with --check
- `npm run type:check` - TypeScript with --noEmit
- `npm run test:staged` - Run tests for staged files only

### Performance Optimization

- Use lint-staged for incremental checking
- Cache TypeScript compilation results
- Skip tests for documentation-only changes
- Parallel execution where possible

## Validation Criteria

- [ ] Git hooks install automatically during `npm install`
- [ ] Pre-commit hook validates code quality without modifying files
- [ ] Hook failures provide clear, actionable error messages
- [ ] Hooks run efficiently by checking only staged files
- [ ] Developer can bypass hooks for emergency commits using `--no-verify`
- [ ] Same validation rules applied in hooks and CI pipeline
- [ ] Documentation explains hook behavior and troubleshooting
