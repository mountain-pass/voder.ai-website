# BIZ-SEMANTIC-NARRATIVE-STRUCTURE: Proper HTML Structure for Narrative Content

## Release Goal

_"Release 1.0: MVP Problem Validation - Foundation Story 2/14 - Organize narrative content with proper semantic HTML structure"_

Organize the static narrative content into clear, semantic HTML structure with proper sections for each narrative act (Magic → Peak → Turn → Chaos → Reality). This provides the foundation for styling and future animations while ensuring accessibility.

## How This Story Contributes

This story builds on the static content foundation by adding proper semantic structure. Following Gall's Law, we establish clear content organization before adding visual styling or interactivity. This ensures the content is accessible and provides the structural foundation for all future enhancements.

## User Story

So that the narrative content is well-organized and accessible, as a user and developer, I want the "Remember when..." content structured with proper semantic HTML elements that clearly delineate each narrative act and provide a solid foundation for styling and animation.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented after static content foundation
- **Negotiable**: Specific semantic elements and structure can be refined
- **Valuable**: Provides accessible, well-organized content structure
- **Estimable**: Clear scope - HTML semantic markup organization
- **Small**: Single component focusing only on content structure
- **Testable**: Structure is semantically correct and accessible

## Acceptance Criteria

- [ ] **Semantic HTML Elements**: Use proper section, article, and heading elements
- [ ] **Clear Act Structure**: Each narrative act (Magic, Peak, Turn, Chaos, Reality) in its own semantic section
- [ ] **Proper Heading Hierarchy**: Logical h1-h6 structure for accessibility
- [ ] **Accessibility Compliance**: Structure supports screen readers and assistive technology
- [ ] **Clean Markup**: Semantic elements without presentation classes
- [ ] **Content Organization**: Clear logical flow through narrative acts
- [ ] **Maintainable Structure**: Easy to understand and modify for future enhancements
- [ ] **Valid HTML**: Passes HTML validation without errors

## Requirements

### Scroll Detection System

- **REQ-PROGRESS-CALCULATION**: Calculate scroll progress as percentage (0-100%) through narrative section
- **REQ-BOUNDARY-DETECTION**: Detect when narrative section enters and exits viewport
- **REQ-SMOOTH-MONITORING**: Use requestAnimationFrame to prevent scroll jank
- **REQ-EFFICIENT-EVENTS**: Throttle scroll events for optimal performance

### Progress Tracking

- **REQ-ACCURATE-MATH**: Precise percentage calculation based on section height and position
- **REQ-BIDIRECTIONAL**: Track both forward and backward scrolling
- **REQ-BOUNDARY-AWARENESS**: Handle edge cases when section is partially visible
- **REQ-DEVICE-AGNOSTIC**: Work consistently across different screen sizes

### Technical Implementation

- **REQ-INTERSECTION-OBSERVER**: Use Intersection Observer API for efficient section detection
- **REQ-SCROLL-HANDLER**: Lightweight scroll event handler with performance optimization
- **REQ-DEBUG-LOGGING**: Console output for development and testing
- **REQ-CLEAN-ARCHITECTURE**: Modular code structure ready for enhancement

## Dependencies

- 026.00-BIZ-NARRATIVE-CONTENT-FOUNDATION (requires static content to be in place)

## Implementation Notes

### Scroll Detection Architecture

```javascript
class ScrollNarrativeDetector {
  constructor() {
    this.narrativeSection = document.querySelector('.narrative-content');
    this.isInView = false;
    this.scrollProgress = 0;

    this.setupIntersectionObserver();
    this.setupScrollHandler();
  }

  setupIntersectionObserver() {
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          this.isInView = entry.isIntersecting;
          if (this.isInView) {
            this.updateScrollProgress();
          }
        });
      },
      { threshold: 0.1 },
    );

    observer.observe(this.narrativeSection);
  }

  setupScrollHandler() {
    let ticking = false;

    window.addEventListener('scroll', () => {
      if (!ticking && this.isInView) {
        requestAnimationFrame(() => {
          this.updateScrollProgress();
          ticking = false;
        });
        ticking = true;
      }
    });
  }

  updateScrollProgress() {
    const rect = this.narrativeSection.getBoundingClientRect();
    const windowHeight = window.innerHeight;

    // Calculate progress based on section visibility
    let progress = 0;
    if (rect.top < windowHeight && rect.bottom > 0) {
      const visibleHeight =
        Math.min(rect.bottom, windowHeight) - Math.max(rect.top, 0);
      const totalHeight = rect.height;
      progress = Math.max(
        0,
        Math.min(100, (visibleHeight / totalHeight) * 100),
      );
    }

    this.scrollProgress = progress;
    console.log(
      `Narrative scroll progress: ${this.scrollProgress.toFixed(1)}%`,
    );
  }
}
```

### Performance Considerations

- Use `requestAnimationFrame` for smooth updates
- Throttle scroll events to prevent excessive calculations
- Only run calculations when section is in viewport
- Efficient DOM queries with cached selectors

### Debug Output

```javascript
// Console logging format:
// "Narrative scroll progress: 25.4%"
// "Narrative section entered viewport"
// "Narrative section exited viewport"
```

### Success Criteria

- Accurate progress percentages logged to console
- Smooth performance during scrolling
- Works consistently across devices
- No visual changes to page
- Clean, extensible code architecture

This story provides the essential scroll monitoring foundation that enables all subsequent scroll-driven animation and cinematic effects.
