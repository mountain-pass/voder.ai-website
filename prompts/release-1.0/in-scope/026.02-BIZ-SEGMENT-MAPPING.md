# BIZ-TYPOGRAPHY-HIERARCHY: Visual Hierarchy for Narrative Progression

## Release Goal

_"Release 1.0: MVP Problem Validation - Visual Story 3/14 - Establish typography hierarchy that supports emotional progression"_

Establish visual hierarchy and emotional tone through typography choices. Create font sizes, weights, and spacing that guide readers through the emotional arc from excitement to frustration, providing the visual foundation for the narrative without requiring animations.

## How This Story Contributes

This story builds on semantic structure to add visual hierarchy. Following Gall's Law, we establish clear visual communication through typography before adding color, interactivity, or motion. This ensures the emotional journey is communicated effectively through text treatment alone.

## User Story

So that I can feel the emotional progression of the AI coding journey through text presentation, as a user reading the narrative, I want typography that visually guides me through the emotional arc with appropriate sizing, weight, and spacing that supports each act's emotional tone.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented after scroll detection foundation
- **Negotiable**: Specific scroll ranges and segment boundaries can be adjusted
- **Valuable**: Provides essential story pacing for scroll-driven narrative
- **Estimable**: Clear scope - mapping logic and segment state management
- **Small**: Single component focusing only on mapping calculations
- **Testable**: Console logging shows which segments are active at each scroll position

## Acceptance Criteria

- [ ] **Segment Progress Mapping**: Each narrative segment has defined scroll range (0-100%)
- [ ] **Active Segment Detection**: System knows which segment(s) should be active at current scroll position
- [ ] **Smooth Transitions**: Segment boundaries transition smoothly without gaps or overlaps
- [ ] **Bidirectional Mapping**: Works correctly for both forward and backward scrolling
- [ ] **Debug Visibility**: Console logging shows active segments and transition points
- [ ] **Configurable Ranges**: Segment boundaries can be easily adjusted
- [ ] **No Visual Effects**: Only mapping logic, no style changes or animations
- [ ] **Act-Based Organization**: Segments grouped by narrative acts (Magic, Peak, Turn, Chaos, Reality)

## Requirements

### Segment Mapping System

- **REQ-PERCENTAGE-RANGES**: Each segment has defined start and end scroll percentages
- **REQ-ACTIVE-DETECTION**: Calculate which segments are active at current scroll position
- **REQ-SMOOTH-BOUNDARIES**: Overlapping ranges for smooth transitions between segments
- **REQ-ACT-ORGANIZATION**: Segments grouped by narrative acts for logical organization

### Narrative Structure

- **REQ-FIVE-ACTS**: Map all five narrative acts:
  1. Magic (0-20%): Segments 1-2
  2. Peak (20-40%): Segments 3-4
  3. Turn (40-60%): Segment 5
  4. Chaos (60-80%): Segment 6
  5. Reality (80-100%): Segments 7-8

- **REQ-SEGMENT-TIMING**: Each segment has optimal scroll range for pacing
- **REQ-TRANSITION-ZONES**: Smooth handoffs between segments

### Technical Implementation

- **REQ-CONFIGURABLE-MAP**: Segment ranges easily adjustable through configuration
- **REQ-STATE-TRACKING**: Track current active segments and transitions
- **REQ-DEBUG-LOGGING**: Clear console output showing segment states
- **REQ-EFFICIENT-CALCULATION**: Lightweight mapping calculations

## Dependencies

- 026.01-BIZ-SCROLL-DETECTION (requires scroll progress tracking)

## Implementation Notes

### Segment Mapping Configuration

```javascript
const narrativeMap = {
  acts: {
    magic: {
      range: [0, 20],
      segments: [
        {
          id: 1,
          range: [0, 12],
          content: 'Remember when AI coding felt like magic?',
        },
        {
          id: 2,
          range: [8, 20],
          content: 'When shipping features was fast and exciting?',
        },
      ],
    },
    peak: {
      range: [20, 40],
      segments: [
        {
          id: 3,
          range: [18, 32],
          content: 'You showed it to your team. You posted about it.',
        },
        {
          id: 4,
          range: [28, 40],
          content: 'Features flew into production. You felt unstoppable.',
        },
      ],
    },
    turn: {
      range: [40, 60],
      segments: [{ id: 5, range: [38, 60], content: 'Then it happened...' }],
    },
    chaos: {
      range: [60, 80],
      segments: [
        {
          id: 6,
          range: [58, 80],
          content: 'Your codebase became a nightmare. Nothing works.',
        },
      ],
    },
    reality: {
      range: [80, 100],
      segments: [
        {
          id: 7,
          range: [78, 92],
          content: 'The excitement turned to dread. Magic became quicksand.',
        },
        {
          id: 8,
          range: [88, 100],
          content: "Now you're stuck cleaning up the mess...",
        },
      ],
    },
  },
};
```

### Mapping Logic

```javascript
class SegmentMapper {
  constructor(narrativeMap) {
    this.narrativeMap = narrativeMap;
    this.activeSegments = new Set();
    this.currentAct = null;
  }

  updateSegmentStates(scrollProgress) {
    const previousActive = new Set(this.activeSegments);
    this.activeSegments.clear();

    // Find active act
    this.currentAct = this.findActiveAct(scrollProgress);

    // Find active segments
    if (this.currentAct) {
      this.currentAct.segments.forEach((segment) => {
        if (this.isSegmentActive(segment, scrollProgress)) {
          this.activeSegments.add(segment.id);
        }
      });
    }

    // Log changes
    if (!this.setsEqual(previousActive, this.activeSegments)) {
      this.logSegmentChange(scrollProgress);
    }
  }

  findActiveAct(scrollProgress) {
    for (const [actName, act] of Object.entries(this.narrativeMap.acts)) {
      if (scrollProgress >= act.range[0] && scrollProgress <= act.range[1]) {
        return { name: actName, ...act };
      }
    }
    return null;
  }

  isSegmentActive(segment, scrollProgress) {
    return (
      scrollProgress >= segment.range[0] && scrollProgress <= segment.range[1]
    );
  }

  logSegmentChange(scrollProgress) {
    const activeIds = Array.from(this.activeSegments).sort();
    console.log(
      `Scroll ${scrollProgress.toFixed(1)}% - Act: ${this.currentAct?.name || 'none'} - Active segments: [${activeIds.join(', ')}]`,
    );
  }
}
```

### Debug Output Format

```javascript
// Console logging examples:
// "Scroll 15.2% - Act: magic - Active segments: [1, 2]"
// "Scroll 45.8% - Act: turn - Active segments: [5]"
// "Scroll 85.3% - Act: reality - Active segments: [7, 8]"
```

### Segment Configuration Strategy

- **Overlapping Ranges**: Segments overlap by 2-4% for smooth transitions
- **Act Boundaries**: Acts have slight overlap to prevent gaps
- **Adjustable Timing**: Configuration allows easy pacing adjustments
- **Visual Mapping**: Each segment range optimized for reading speed

### Success Criteria

- Accurate segment detection at all scroll positions
- Smooth transitions between segments and acts
- Clear debug logging showing segment states
- No gaps or double-coverage in mapping
- Easy configuration for timing adjustments

This story establishes the timing foundation that enables all subsequent progressive disclosure and animation effects.
