# BIZ-VIEWPORT-FIXED-OVERLAY: Cinematic Scroll-Locked Narrative Reveal

## Release Goal

_"Release 1.0: MVP Problem Validation - Foundation Story 2/14 - Implement scroll-locked narrative reveal for cinematic storytelling"_

Implement a scroll-locked narrative reveal where narrative content pins in the viewport while users scroll through the story, with content animating in based on scroll progress. This creates the essential cinematic timeline scrubbing experience without scroll-jacking.

## How This Story Contributes

This story implements the core visual feature that transforms the narrative from basic scroll-driven content to cinematic storytelling. The pinned narrative with progressive reveal demonstrates technical sophistication while maintaining natural scroll behavior that makes the experience compelling and memorable.

## User Story

So that I experience cinematic timeline scrubbing through the narrative, as a user scrolling through the site, I want the narrative content to stay pinned in my viewport while I scroll through the story timeline, with content revealing progressively, creating an immersive film-like experience without scroll-jacking.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented after scroll detection
- **Negotiable**: Specific positioning calculations and transition timing can be refined
- **Valuable**: Enables cinematic storytelling and demonstrates technical sophistication
- **Estimable**: Clear scope - viewport positioning with seamless transitions
- **Small**: Single component focusing on positioning mechanics
- **Testable**: Fixed positioning works correctly with smooth transitions

## Acceptance Criteria

- [ ] **Pinned Narrative**: Narrative content pins at viewport top during narrative scroll range
- [ ] **Progressive Reveal**: Content elements animate in based on scroll progress through pinned section
- [ ] **Natural Scrolling**: Users scroll normally through the page without scroll-jacking or fighting
- [ ] **Scroll Stage**: Tall container creates scroll distance for progressive reveal
- [ ] **Smooth Animations**: Content fades and translates in smoothly based on scroll position
- [ ] **Scroll Progress Tracking**: Calculate 0-1 progress through the narrative scroll stage
- [ ] **Normal Flow Resume**: Content returns to natural document flow after narrative completes
- [ ] **Cross-Device Compatibility**: Works consistently across desktop, tablet, and mobile
- [ ] **Reduced Motion**: Respects prefers-reduced-motion preference

## Requirements

### Scroll Stage System

- **REQ-SCROLL-STAGE**: Parent container with height based on number of reveal steps
- **REQ-STICKY-PINNING**: Narrative panel uses position:sticky to pin at viewport top
- **REQ-NATURAL-SCROLL**: Users scroll normally without any scroll hijacking or intervention
- **REQ-PROGRESS-CALC**: Calculate 0-1 scroll progress through the narrative stage

### Progressive Reveal

- **REQ-ELEMENT-TIMING**: Each content element has start/end thresholds (0-1 range)
- **REQ-SMOOTH-ANIMATION**: Content fades and translates based on scroll progress
- **REQ-EASING-FUNCTION**: Use smoothstep or similar for natural animation feel
- **REQ-OPACITY-TRANSFORM**: Animate both opacity and translateY for reveal effect

### Performance

- **REQ-RAF-THROTTLE**: Use requestAnimationFrame for scroll updates
- **REQ-EFFICIENT-CALC**: Cache calculations and minimize layout thrashing
- **REQ-RESIZE-OBSERVE**: Update on resize with ResizeObserver
- **REQ-REDUCED-MOTION**: Disable animations when prefers-reduced-motion is set

## Dependencies

- 026.01-BIZ-SCROLL-DETECTION (requires scroll position tracking)

## Implementation Notes

### HTML Structure

```html
<!-- Spacer before narrative -->
<div class="spacer" style="height: 20vh"></div>

<!-- Scroll stage with sticky panel -->
<section class="scroll-stage" style="--reveal-steps: 4">
  <div class="sticky-panel">
    <div class="panel">
      <p class="reveal-line" data-reveal-start="0.0" data-reveal-end="0.25">
        Introducing
      </p>
      <h2 class="reveal-line" data-reveal-start="0.2" data-reveal-end="0.5">
        Scroll-driven storytelling
      </h2>
      <p class="reveal-line" data-reveal-start="0.45" data-reveal-end="0.75">
        Content reveals progressively as you scroll
      </p>
      <button class="reveal-line" data-reveal-start="0.7" data-reveal-end="1.0">
        Get started
      </button>
    </div>
  </div>
</section>

<!-- Normal content resumes -->
<main class="after-narrative">
  <h2>Content continues normally</h2>
  <p>Regular page flow resumes after the narrative...</p>
</main>
```

### CSS Foundation

```css
/* Scroll stage: creates scroll distance */
.scroll-stage {
  position: relative;
  /* Height based on number of steps: (steps + 1) × 100vh */
  height: calc((var(--reveal-steps, 4) + 1) * 100vh);
}

/* Sticky panel: pins at viewport top while parent scrolls */
.scroll-stage .sticky-panel {
  position: sticky;
  top: 0;
  height: 100vh;
  display: grid;
  place-items: center;
}

/* Panel content */
.panel {
  max-width: min(900px, 90vw);
  padding: clamp(16px, 4vw, 48px);
  border-radius: 24px;
  background: rgba(15, 23, 42, 0.6);
  backdrop-filter: blur(6px);
  box-shadow: 0 10px 40px rgba(0, 0, 0, 0.25);
}

/* Elements that reveal progressively */
.reveal-line {
  opacity: 0;
  transform: translateY(20px) scale(0.98);
  transition:
    opacity 0.3s linear,
    transform 0.3s ease-out;
  will-change: transform, opacity;
}

/* Reduced motion support */
@media (prefers-reduced-motion: reduce) {
  .scroll-stage {
    height: auto;
  }
  .scroll-stage .sticky-panel {
    position: static;
    height: auto;
  }
  .reveal-line {
    opacity: 1 !important;
    transform: none !important;
    transition: none !important;
  }
}
```

### JavaScript Implementation

```javascript
class ScrollLockedReveal {
  constructor() {
    this.stage = document.querySelector('.scroll-stage');
    this.elements = Array.from(
      this.stage?.querySelectorAll('[data-reveal-start]') || [],
    );
    this.ticking = false;

    this.setup();
  }

  setup() {
    if (!this.stage) return;

    // Scroll listener with rAF throttling
    window.addEventListener('scroll', () => this.onScroll(), { passive: true });
    window.addEventListener('resize', () => this.onScroll(), { passive: true });

    // Observe stage for size changes
    const ro = new ResizeObserver(() => this.update());
    ro.observe(this.stage);

    // Initial update
    this.update();
  }

  onScroll() {
    if (!this.ticking) {
      requestAnimationFrame(() => {
        this.update();
        this.ticking = false;
      });
      this.ticking = true;
    }
  }

  getProgress() {
    // Calculate 0-1 progress through the scroll stage
    const rect = this.stage.getBoundingClientRect();
    const total = this.stage.offsetHeight - window.innerHeight;
    const scrolled = Math.max(0, Math.min(-rect.top, total));
    return total > 0 ? scrolled / total : 0;
  }

  update() {
    const progress = this.getProgress();

    for (const el of this.elements) {
      const start = parseFloat(el.dataset.revealStart || 0);
      const end = parseFloat(el.dataset.revealEnd || 1);

      // Map global progress to element's local 0-1 range
      const range = Math.max(0.0001, end - start);
      const local = Math.max(0, Math.min(1, (progress - start) / range));

      // Apply smoothstep easing: 3x² - 2x³
      const eased = local * local * (3 - 2 * local);

      // Animate opacity and transform
      el.style.opacity = eased;
      el.style.transform = `translateY(${(1 - eased) * 20}px) scale(${0.98 + 0.02 * eased})`;
    }
  }
}
```

### Progress Calculation

```javascript
// Calculate 0-1 progress through scroll stage
function getProgress() {
  const rect = stage.getBoundingClientRect();
  const total = stage.offsetHeight - window.innerHeight; // scrollable distance
  const scrolled = Math.max(0, Math.min(-rect.top, total));
  return total > 0 ? scrolled / total : 0; // 0 → 1
}
```

### Element Reveal Timing

```javascript
// Each element defines when it should reveal:
// data-reveal-start="0.0" data-reveal-end="0.25" (first quarter)
// data-reveal-start="0.2" data-reveal-end="0.5" (overlapping second quarter)
// data-reveal-start="0.45" data-reveal-end="0.75" (third quarter)
// data-reveal-start="0.7" data-reveal-end="1.0" (final quarter)

function updateElementReveal(element, globalProgress) {
  const start = parseFloat(element.dataset.revealStart || 0);
  const end = parseFloat(element.dataset.revealEnd || 1);

  // Map global progress to element's local progress
  const range = Math.max(0.0001, end - start);
  const local = Math.max(0, Math.min(1, (globalProgress - start) / range));

  // Apply smoothstep easing: 3x² - 2x³
  const eased = local * local * (3 - 2 * local);

  return eased;
}
```

### Debug Output

```javascript
// Console logging for development:
// "Scroll progress: 0.234 (23.4% through narrative)"
// "Element 1 reveal: 0.85 (85% visible)"
// "Element 2 reveal: 0.00 (not yet visible)"
```

### Performance Considerations

- Use requestAnimationFrame to throttle scroll updates
- Cache DOM queries and reuse element references
- Use `will-change: transform, opacity` for animated elements
- Minimize layout recalculations with transform/opacity only
- ResizeObserver for efficient resize handling

### Success Criteria

- Content pins at viewport top and stays there while scrolling through narrative
- Elements reveal progressively based on scroll progress with smooth animations
- No scroll-jacking - users scroll naturally through the page
- Smooth cinematic timeline scrubbing experience
- Works consistently across all device sizes
- Performance remains smooth during scrolling
- Respects reduced motion preferences

This story enables the sophisticated cinematic storytelling that demonstrates technical capability beyond typical AI-assisted development.
