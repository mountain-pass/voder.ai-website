# BIZ-VIEWPORT-FIXED-OVERLAY: Cinematic Viewport-Fixed Positioning

## Release Goal

_"Release 1.0: MVP Problem Validation - Foundation Story 2/14 - Implement viewport-fixed overlay for cinematic scroll-jacking"_

Implement the sophisticated viewport-fixed overlay positioning system that enables cinematic storytelling by fixing narrative content in the viewport while users scroll. This creates the essential cinematic timeline scrubbing experience that demonstrates technical sophistication.

## How This Story Contributes

This story implements the core technical feature that transforms the narrative from basic scroll-driven content to cinematic storytelling. The viewport-fixed overlay demonstrates technical sophistication while enabling the immersive timeline scrubbing experience that makes the narrative compelling and memorable.

## User Story

So that I experience cinematic timeline scrubbing through the narrative, as a user scrolling through the site, I want the narrative content to be fixed in my viewport while I scrub through the story timeline, creating an immersive film-like experience that demonstrates technical sophistication beyond typical AI-assisted development.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented after scroll detection
- **Negotiable**: Specific positioning calculations and transition timing can be refined
- **Valuable**: Enables cinematic storytelling and demonstrates technical sophistication
- **Estimable**: Clear scope - viewport positioning with seamless transitions
- **Small**: Single component focusing on positioning mechanics
- **Testable**: Fixed positioning works correctly with smooth transitions

## Acceptance Criteria

- [ ] **Viewport-Fixed Positioning**: Narrative content fixed in viewport during active scroll range
- [ ] **Seamless Position Matching**: Mathematical precision in natural-to-fixed position transitions
- [ ] **Zero Visual Jumps**: No visual discontinuity when switching between positioning modes
- [ ] **Measured Coordinates**: Use getBoundingClientRect to calculate exact positioning
- [ ] **Smooth Transitions**: Clean entry and exit from fixed overlay mode
- [ ] **Scroll Range Control**: Fixed positioning only active during narrative scroll boundaries
- [ ] **Natural Flow Fallback**: Content returns to natural document flow after narrative complete
- [ ] **Cross-Device Compatibility**: Works consistently across desktop, tablet, and mobile

## Requirements

### Viewport-Fixed System

- **REQ-FIXED-POSITIONING**: Use position: fixed for viewport overlay during narrative
- **REQ-MEASURED-COORDINATES**: Calculate fixed position from natural flow measurements
- **REQ-SEAMLESS-MATCHING**: Fixed position must visually match natural position exactly
- **REQ-SCROLL-BOUNDARIES**: Enable/disable fixed mode based on scroll position

### Position Calculations

- **REQ-BOUNDING-RECT**: Use getBoundingClientRect for accurate position measurements
- **REQ-VIEWPORT-MAPPING**: Map natural position to equivalent fixed coordinates
- **REQ-OFFSET-COMPENSATION**: Account for scroll offset and viewport positioning
- **REQ-PRECISION-MATCHING**: Mathematical precision to eliminate visual jumps

### Transition Management

- **REQ-ENTRY-TRANSITION**: Smooth transition from natural to fixed positioning
- **REQ-EXIT-TRANSITION**: Smooth transition from fixed to natural positioning
- **REQ-STATE-TRACKING**: Track current positioning mode (natural/fixed/transitioning)
- **REQ-BOUNDARY-DETECTION**: Detect when to switch positioning modes

## Dependencies

- 026.01-BIZ-SCROLL-DETECTION (requires scroll position tracking)

## Implementation Notes

### Viewport-Fixed Positioning System

```javascript
class ViewportFixedOverlay {
  constructor(scrollDetector) {
    this.scrollDetector = scrollDetector;
    this.narrativeSection = document.querySelector('.narrative-content');
    this.isFixedMode = false;
    this.naturalPosition = null;
    this.scrollBoundaries = { start: 0, end: 0 };

    this.setupPositioning();
    this.bindScrollUpdates();
  }

  setupPositioning() {
    // Calculate scroll boundaries for fixed mode
    this.calculateScrollBoundaries();

    // Measure natural position for seamless matching
    this.measureNaturalPosition();

    // Setup resize handler for recalculation
    window.addEventListener('resize', () => {
      this.recalculatePositioning();
    });
  }

  calculateScrollBoundaries() {
    // Fixed mode should be active during narrative scroll range
    const narrativeRect = this.narrativeSection.getBoundingClientRect();
    const scrollTop = window.pageYOffset;

    // Start fixed mode when narrative enters viewport
    this.scrollBoundaries.start =
      scrollTop + narrativeRect.top - window.innerHeight * 0.2;

    // End fixed mode when narrative should complete
    this.scrollBoundaries.end =
      scrollTop +
      narrativeRect.top +
      narrativeRect.height +
      window.innerHeight * 0.8;

    console.log(
      `Fixed overlay boundaries: ${this.scrollBoundaries.start}px - ${this.scrollBoundaries.end}px`,
    );
  }

  measureNaturalPosition() {
    // Ensure we're measuring natural position
    this.narrativeSection.classList.remove('viewport-fixed');

    // Force layout recalculation
    this.narrativeSection.offsetHeight;

    // Measure natural position
    const rect = this.narrativeSection.getBoundingClientRect();
    const scrollTop = window.pageYOffset;

    this.naturalPosition = {
      top: rect.top + scrollTop,
      left: rect.left,
      width: rect.width,
      height: rect.height,
      centerX: rect.left + rect.width / 2,
      centerY: rect.top + rect.height / 2,
    };

    console.log('Natural position measured:', this.naturalPosition);
  }

  bindScrollUpdates() {
    // Hook into scroll detector
    this.scrollDetector.onScroll(() => {
      this.updateViewportPositioning();
    });
  }

  updateViewportPositioning() {
    const currentScroll = window.pageYOffset;
    const shouldBeFixed =
      currentScroll >= this.scrollBoundaries.start &&
      currentScroll <= this.scrollBoundaries.end;

    if (shouldBeFixed && !this.isFixedMode) {
      this.enterFixedMode();
    } else if (!shouldBeFixed && this.isFixedMode) {
      this.exitFixedMode();
    }

    if (this.isFixedMode) {
      this.updateFixedPosition();
    }
  }

  enterFixedMode() {
    console.log('Entering viewport-fixed mode');

    // Calculate fixed position that matches current natural position
    const fixedPosition = this.calculateFixedPosition();

    // Apply fixed positioning with matching coordinates
    this.narrativeSection.style.position = 'fixed';
    this.narrativeSection.style.top = `${fixedPosition.top}px`;
    this.narrativeSection.style.left = `${fixedPosition.left}px`;
    this.narrativeSection.style.width = `${fixedPosition.width}px`;
    this.narrativeSection.style.zIndex = '10';

    // Add fixed mode class for styling
    this.narrativeSection.classList.add('viewport-fixed');

    this.isFixedMode = true;
  }

  calculateFixedPosition() {
    // Calculate viewport-centered position
    const viewportCenterX = window.innerWidth / 2;
    const viewportCenterY = window.innerHeight / 2;

    // Position content in center of viewport
    return {
      top: viewportCenterY - this.naturalPosition.height / 2,
      left: viewportCenterX - this.naturalPosition.width / 2,
      width: this.naturalPosition.width,
    };
  }

  updateFixedPosition() {
    // Ensure fixed position remains centered during scroll
    const fixedPosition = this.calculateFixedPosition();

    this.narrativeSection.style.top = `${fixedPosition.top}px`;
    this.narrativeSection.style.left = `${fixedPosition.left}px`;
  }

  exitFixedMode() {
    console.log('Exiting viewport-fixed mode');

    // Remove fixed positioning
    this.narrativeSection.style.position = '';
    this.narrativeSection.style.top = '';
    this.narrativeSection.style.left = '';
    this.narrativeSection.style.width = '';
    this.narrativeSection.style.zIndex = '';

    // Remove fixed mode class
    this.narrativeSection.classList.remove('viewport-fixed');

    this.isFixedMode = false;
  }

  recalculatePositioning() {
    // Recalculate on resize
    if (this.isFixedMode) {
      this.exitFixedMode();
    }

    // Wait for layout to stabilize
    setTimeout(() => {
      this.calculateScrollBoundaries();
      this.measureNaturalPosition();
    }, 100);
  }
}
```

### CSS Foundation for Fixed Positioning

```css
.narrative-content {
  /* Natural flow default */
  position: static;
  max-width: 800px;
  margin: 0 auto;
  padding: 2rem;
  transition: none; /* Disable transitions during positioning changes */
}

.narrative-content.viewport-fixed {
  /* Fixed positioning mode */
  position: fixed;
  /* Coordinates set dynamically by JavaScript */
  z-index: 10;

  /* Ensure content remains centered and readable */
  max-width: 800px;
  padding: 2rem;

  /* Subtle backdrop for readability */
  background: rgba(0, 0, 0, 0.05);
  backdrop-filter: blur(20px);
  border-radius: 12px;
}

/* Smooth backdrop transition */
.narrative-content.viewport-fixed::before {
  content: '';
  position: absolute;
  top: -20px;
  left: -20px;
  right: -20px;
  bottom: -20px;
  background: radial-gradient(circle, rgba(0, 0, 0, 0.1) 0%, transparent 70%);
  border-radius: 20px;
  z-index: -1;
}

/* Ensure text remains readable in fixed mode */
.narrative-content.viewport-fixed .narrative-segment {
  text-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
}

/* Responsive adjustments */
@media (max-width: 768px) {
  .narrative-content.viewport-fixed {
    max-width: 90vw;
    padding: 1.5rem;
  }
}

@media (max-width: 480px) {
  .narrative-content.viewport-fixed {
    max-width: 95vw;
    padding: 1rem;
  }
}
```

### Position Calculation Strategy

```javascript
// Precise position matching
function calculateSeamlessPosition() {
  // 1. Measure natural position
  const naturalRect = element.getBoundingClientRect();
  const scrollTop = window.pageYOffset;

  // 2. Calculate equivalent fixed position
  const fixedTop = naturalRect.top; // Current viewport position
  const fixedLeft = naturalRect.left; // Current viewport position

  // 3. Apply with zero visual jump
  element.style.position = 'fixed';
  element.style.top = `${fixedTop}px`;
  element.style.left = `${fixedLeft}px`;

  return { top: fixedTop, left: fixedLeft };
}
```

### Scroll Boundary Management

```javascript
// Dynamic boundary calculation
function updateScrollBoundaries() {
  const narrativeStart = naturalPosition.top - window.innerHeight * 0.2;
  const narrativeEnd =
    naturalPosition.top + naturalPosition.height + window.innerHeight * 0.8;

  return {
    enterFixed: narrativeStart,
    exitFixed: narrativeEnd,
  };
}
```

### Debug Output

```javascript
// Console logging for development:
// "Fixed overlay boundaries: 1250px - 3500px"
// "Entering viewport-fixed mode"
// "Fixed position: top 200px, left 300px"
// "Exiting viewport-fixed mode"
```

### Performance Considerations

- Cache position calculations to avoid repeated measurements
- Use `will-change: transform` for smooth positioning
- Minimize layout recalculations during scroll
- Efficient scroll event handling with requestAnimationFrame

### Success Criteria

- Content seamlessly transitions between natural and fixed positioning
- Zero visual jumps during position mode changes
- Smooth cinematic timeline scrubbing experience
- Works consistently across all device sizes
- Performance remains smooth during fixed positioning
- Foundation ready for final polish and optimization

This story enables the sophisticated cinematic storytelling that demonstrates technical capability beyond typical AI-assisted development.
