# BIZ-COLOR-ATMOSPHERE: Visual Mood Through Color Progression

## Release Goal

_"Release 1.0: MVP Problem Validation - Visual Story 4/14 - Establish color palette that supports emotional progression"_

Implement a color system that supports the emotional progression through each narrative act. Create background colors, text colors, and atmospheric visual cues that transition through the acts (Magic → Peak → Turn → Chaos → Reality) without requiring animations.

## How This Story Contributes

This story builds on typography hierarchy to add emotional color language. Following Gall's Law, we establish visual mood through static color before adding interactivity or motion. This ensures each act has distinct visual character that supports the emotional journey.

## User Story

So that I feel the emotional shifts in the AI coding narrative through visual atmosphere, as a user reading through each act, I want color treatments that reinforce the mood progression from magical warmth through peak energy to chaotic distress and final resignation.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented after segment mapping foundation
- **Negotiable**: Specific reveal timing and transition style can be adjusted
- **Valuable**: Provides working scroll-driven narrative experience
- **Estimable**: Clear scope - opacity-based show/hide implementation
- **Small**: Single component focusing only on basic visibility control
- **Testable**: Segments visibly appear and disappear at correct scroll positions

## Acceptance Criteria

- [ ] **Scroll-Driven Visibility**: Segments appear when scroll progress enters their range
- [ ] **Smooth Opacity Transitions**: Gentle fade in/out effects using CSS transitions
- [ ] **Accurate Timing**: Segments become visible at exact scroll percentages defined in mapping
- [ ] **Bidirectional Scrolling**: Content appears/disappears correctly when scrolling up or down
- [ ] **Initial State**: All segments start hidden, first segment appears immediately when entering section
- [ ] **Clean Transitions**: No jarring jumps or visual glitches during reveal/hide
- [ ] **Performance Optimized**: Smooth 60fps opacity changes
- [ ] **Mobile Compatible**: Works consistently on touch devices

## Requirements

### Progressive Disclosure System

- **REQ-OPACITY-CONTROL**: Use opacity (0-1) for segment visibility control
- **REQ-CSS-TRANSITIONS**: Smooth CSS transitions for fade effects
- **REQ-SCROLL-TRIGGERED**: Visibility changes triggered by scroll progress
- **REQ-SEGMENT-INDEPENDENT**: Each segment controls its own visibility state

### Visibility Logic

- **REQ-RANGE-BASED**: Segments visible only when scroll is within their defined range
- **REQ-IMMEDIATE-RESPONSE**: Visibility changes respond instantly to scroll position
- **REQ-SMOOTH-TRANSITIONS**: Gentle fade timing (300-500ms) for professional feel
- **REQ-INITIAL-HIDDEN**: All segments start with opacity: 0

### Technical Implementation

- **REQ-CSS-CLASSES**: Use CSS classes for visibility states (visible/hidden)
- **REQ-EFFICIENT-UPDATES**: Only update segments whose state actually changed
- **REQ-HARDWARE-ACCELERATION**: Use will-change: opacity for smooth performance
- **REQ-FALLBACK-SUPPORT**: Works even if CSS transitions not supported

## Dependencies

- 026.02-BIZ-SEGMENT-MAPPING (requires segment mapping system)

## Implementation Notes

### CSS Foundation

```css
.narrative-segment {
  opacity: 0;
  transition: opacity 0.4s ease-out;
  will-change: opacity;
}

.narrative-segment.visible {
  opacity: 1;
}

.narrative-segment.hidden {
  opacity: 0;
}

/* Reduce motion preference support */
@media (prefers-reduced-motion: reduce) {
  .narrative-segment {
    transition: opacity 0.1s ease-out;
  }
}
```

### Progressive Reveal Logic

```javascript
class ProgressiveReveal {
  constructor(segmentMapper) {
    this.segmentMapper = segmentMapper;
    this.segments = document.querySelectorAll('.narrative-segment');
    this.visibleSegments = new Set();

    this.initializeSegments();
  }

  initializeSegments() {
    // Start with all segments hidden
    this.segments.forEach((segment) => {
      segment.classList.add('hidden');
      segment.classList.remove('visible');
    });
  }

  updateVisibility(scrollProgress) {
    // Get active segments from mapper
    this.segmentMapper.updateSegmentStates(scrollProgress);
    const activeSegments = this.segmentMapper.activeSegments;

    // Update visibility for each segment
    this.segments.forEach((segment) => {
      const segmentId = parseInt(segment.dataset.segment);
      const shouldBeVisible = activeSegments.has(segmentId);
      const isCurrentlyVisible = this.visibleSegments.has(segmentId);

      if (shouldBeVisible && !isCurrentlyVisible) {
        this.showSegment(segment, segmentId);
      } else if (!shouldBeVisible && isCurrentlyVisible) {
        this.hideSegment(segment, segmentId);
      }
    });
  }

  showSegment(segment, segmentId) {
    segment.classList.remove('hidden');
    segment.classList.add('visible');
    this.visibleSegments.add(segmentId);
    console.log(`Showing segment ${segmentId}`);
  }

  hideSegment(segment, segmentId) {
    segment.classList.remove('visible');
    segment.classList.add('hidden');
    this.visibleSegments.delete(segmentId);
    console.log(`Hiding segment ${segmentId}`);
  }
}
```

### Integration with Scroll Detection

```javascript
// In main scroll handler
function handleScrollUpdate(scrollProgress) {
  // Update segment mapping
  segmentMapper.updateSegmentStates(scrollProgress);

  // Update progressive reveal
  progressiveReveal.updateVisibility(scrollProgress);
}
```

### HTML Structure Requirements

```html
<div class="narrative-segment" data-act="1" data-segment="1">
  <p>
    Remember when AI coding felt like <span class="magic-word">magic</span>?
  </p>
</div>

<div class="narrative-segment" data-act="1" data-segment="2">
  <p>
    When shipping features was
    <span class="speed-word">fast and exciting</span>?
  </p>
</div>
<!-- Additional segments with data-segment attributes... -->
```

### Performance Considerations

- Use `will-change: opacity` for hardware acceleration
- Only update segments whose state actually changed
- Batch DOM updates within requestAnimationFrame
- Cache DOM queries for segment elements

### Accessibility Support

```css
/* Respect reduced motion preferences */
@media (prefers-reduced-motion: reduce) {
  .narrative-segment {
    transition: opacity 0.1s ease-out;
  }
}

/* Ensure content is accessible to screen readers */
.narrative-segment[aria-hidden='true'] {
  opacity: 0;
}
```

### Debug Output

```javascript
// Console logging examples:
// "Showing segment 1"
// "Hiding segment 1"
// "Showing segment 2"
// "Progressive reveal: 2 segments visible"
```

### Success Criteria

- Segments fade in/out smoothly at correct scroll positions
- No visual glitches or jarring transitions
- Works consistently across devices and browsers
- Respects motion preferences for accessibility
- Clean console logging showing visibility changes
- Foundation ready for complex animations

This story provides the essential progressive disclosure mechanism that enables all subsequent cinematic and animation effects.
