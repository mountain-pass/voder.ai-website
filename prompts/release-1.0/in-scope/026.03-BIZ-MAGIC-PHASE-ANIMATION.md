# BIZ-MAGIC-PHASE-ANIMATION: Act 1 Magic Phase Cinematic Effects

## Release Goal

_"Release 1.0: MVP Problem Validation - Interactivity Story 3/14 - Add cinematic animations for Act 1 Magic Phase"_

Implement the first cinematic animations for the Magic Phase (Act 1), creating gentle floating motion, warm glows, and elegant scaling effects that capture the initial wonder and excitement of AI-assisted development.

## How This Story Contributes

This story adds the first cinematic animations to the working progressive reveal foundation. Following Gall's Law, we start with one act's animations to establish the cinematic system before expanding to other acts. The Magic Phase sets the emotional tone for the entire narrative journey.

## User Story

So that I feel the magic and wonder of early AI coding, as a user scrolling through the narrative, I want to see the first two segments animate with gentle floating motion, warm glows, and elegant scaling that captures the initial excitement and possibility of AI-assisted development.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented after progressive reveal foundation
- **Negotiable**: Specific animation timing and effects can be refined
- **Valuable**: Creates emotional connection through cinematic storytelling
- **Estimable**: Clear scope - two segments with defined animation types
- **Small**: Single act focusing on consistent animation language
- **Testable**: Animations visible and emotionally effective during Magic Phase scroll range

## Acceptance Criteria

- [ ] **Floating Motion**: Segments gently float with subtle up/down movement
- [ ] **Ethereal Glow**: "Magic" and key words receive warm, shimmering effects
- [ ] **Elegant Scaling**: Text scales gracefully as it enters and exits view
- [ ] **Smooth Interpolation**: All animations interpolate smoothly based on scroll progress
- [ ] **Performance Optimized**: 60fps animations using CSS transforms
- [ ] **Act-Specific Timing**: Animations active only during 0-20% scroll range
- [ ] **Bidirectional Animation**: Effects work correctly when scrolling backwards
- [ ] **Mobile Compatible**: Animations perform well on touch devices

## Requirements

### Magic Phase Animation Language

- **REQ-GENTLE-MOTION**: Subtle floating motion using translateY transforms
- **REQ-WARM-GLOW**: Golden/teal glow effects on magic-related words
- **REQ-ELEGANT-SCALING**: Graceful scale transitions (0.8x to 1.0x)
- **REQ-ETHEREAL-FEEL**: Dreamy, wonder-filled animation style

### Specific Animations

- **REQ-SEGMENT-1**: "Remember when AI coding felt like magic?"
  - Float in from center with soft glow
  - "Magic" word gets sparkle particles and warm shimmer
  - Gentle floating motion throughout visibility

- **REQ-SEGMENT-2**: "When shipping features was fast and exciting?"
  - Smooth slide in from left
  - "Fast and exciting" gets energy pulse effect
  - Confident emergence with gentle momentum

### Technical Implementation

- **REQ-CSS-TRANSFORMS**: Use hardware-accelerated CSS transforms
- **REQ-SCROLL-INTERPOLATION**: Animation progress based on scroll position within segment range
- **REQ-MAGIC-WORD-EFFECTS**: Special effects for words with .magic-word class
- **REQ-PERFORMANCE-OPTIMIZED**: requestAnimationFrame for smooth updates

## Dependencies

- 026.02-BIZ-VIEWPORT-FIXED-OVERLAY (requires scroll-locked reveal system)

## Implementation Notes

### Animation System Architecture

```javascript
class MagicPhaseAnimator {
  constructor(progressiveReveal) {
    this.progressiveReveal = progressiveReveal;
    this.magicSegments = document.querySelectorAll('[data-act="1"]');
    this.bindAnimationUpdates();
  }

  bindAnimationUpdates() {
    // Hook into the progressive reveal system
    const originalUpdateVisibility =
      this.progressiveReveal.updateVisibility.bind(this.progressiveReveal);

    this.progressiveReveal.updateVisibility = (scrollProgress) => {
      originalUpdateVisibility(scrollProgress);
      this.updateMagicAnimations(scrollProgress);
    };
  }

  updateMagicAnimations(scrollProgress) {
    // Only animate during Magic Phase (0-20%)
    if (scrollProgress >= 0 && scrollProgress <= 20) {
      this.animateSegment1(scrollProgress);
      this.animateSegment2(scrollProgress);
    }
  }

  animateSegment1(scrollProgress) {
    const segment = document.querySelector('[data-segment="1"]');
    if (!segment.classList.contains('visible')) return;

    // Calculate animation progress within segment range (0-12%)
    const segmentProgress = this.mapToSegmentProgress(scrollProgress, 0, 12);

    // Gentle floating motion
    const floatY = Math.sin(Date.now() * 0.001) * 3; // 3px floating range
    const scaleProgress = this.easeOutQuart(segmentProgress);
    const scale = 0.8 + scaleProgress * 0.2; // 0.8 to 1.0

    segment.style.transform = `translateY(${floatY}px) scale(${scale})`;

    // Magic word glow effect
    const magicWord = segment.querySelector('.magic-word');
    if (magicWord) {
      const glowIntensity = 0.5 + Math.sin(Date.now() * 0.002) * 0.3;
      magicWord.style.textShadow = `0 0 ${glowIntensity * 20}px rgba(0, 255, 136, 0.6)`;
    }
  }

  animateSegment2(scrollProgress) {
    const segment = document.querySelector('[data-segment="2"]');
    if (!segment.classList.contains('visible')) return;

    // Calculate animation progress within segment range (8-20%)
    const segmentProgress = this.mapToSegmentProgress(scrollProgress, 8, 20);

    // Slide in from left with momentum
    const slideX = -40 * (1 - this.easeOutBack(segmentProgress));
    const scale = 0.9 + this.easeOutQuart(segmentProgress) * 0.1;

    segment.style.transform = `translateX(${slideX}px) scale(${scale})`;

    // Speed word energy effect
    const speedWord = segment.querySelector('.speed-word');
    if (speedWord) {
      const energyPulse = 1 + Math.sin(Date.now() * 0.003) * 0.1;
      speedWord.style.transform = `scale(${energyPulse})`;
      speedWord.style.color = `hsl(174, 100%, ${45 + energyPulse * 10}%)`;
    }
  }

  mapToSegmentProgress(scrollProgress, start, end) {
    return Math.max(0, Math.min(1, (scrollProgress - start) / (end - start)));
  }

  easeOutQuart(t) {
    return 1 - Math.pow(1 - t, 4);
  }

  easeOutBack(t) {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  }
}
```

### CSS Animation Foundation

```css
.narrative-segment[data-act='1'] {
  transition: opacity 0.4s ease-out;
  will-change: transform, opacity;
}

.magic-word {
  display: inline-block;
  transition: text-shadow 0.3s ease-out;
  will-change: text-shadow;
}

.speed-word {
  display: inline-block;
  transition:
    transform 0.2s ease-out,
    color 0.3s ease-out;
  will-change: transform, color;
}

/* Performance optimization */
.narrative-segment[data-act='1'] {
  backface-visibility: hidden;
  perspective: 1000;
}
```

### Animation Timing Strategy

- **Segment 1 (0-12% scroll)**:
  - Entry: Gentle scale from 0.8 to 1.0
  - Active: Continuous gentle floating motion
  - Magic word: Pulsing golden glow effect

- **Segment 2 (8-20% scroll)**:
  - Entry: Slide in from left (-40px to 0)
  - Active: Slight momentum-based scaling
  - Speed words: Energy pulse and color shift

### Performance Considerations

- Use `transform` instead of changing layout properties
- `will-change` declarations for GPU acceleration
- `backface-visibility: hidden` for optimization
- Efficient easing functions for smooth motion

### Debug Output

```javascript
// Console logging for development:
// "Magic Phase: Segment 1 active - progress: 45.2%"
// "Magic Phase: Animating floating motion at scale 0.92"
// "Magic Phase: Magic word glow intensity: 0.73"
```

### Success Criteria

- Segments float gently with dreamy motion
- Magic words have warm, ethereal glow effects
- Animations feel magical and wonder-filled
- Smooth 60fps performance on all devices
- Animations respect scroll direction (bidirectional)
- Foundation ready for other act animations

This story establishes the cinematic animation system and creates the magical emotional tone for the narrative journey.
