# BIZ-MAGIC-PHASE-ANIMATION: Act 1 Magic Phase Cinematic Effects

## Release Goal

_"Release 1.0: MVP Problem Validation - Interactivity Story 3/14 - Add cinematic animations for Act 1 Magic Phase"_

Implement the first cinematic animations for the Magic Phase (Act 1), creating gentle floating motion, warm glows, and elegant scaling effects that capture the initial wonder and excitement of AI-assisted development.

## How This Story Contributes

This story adds the first cinematic animations to the working progressive reveal foundation. Following Gall's Law, we start with one act's animations to establish the cinematic system before expanding to other acts. The Magic Phase sets the emotional tone for the entire narrative journey.

## User Story

So that I feel the magic and wonder of early AI coding, as a user scrolling through the narrative, I want to see the first two segments animate with gentle floating motion, warm glows, and elegant scaling that captures the initial excitement and possibility of AI-assisted development.

**INVEST Criteria Compliance**:

- **Independent**: Can be implemented after progressive reveal foundation
- **Negotiable**: Specific animation timing and effects can be refined
- **Valuable**: Creates emotional connection through cinematic storytelling
- **Estimable**: Clear scope - two segments with defined animation types
- **Small**: Single act focusing on consistent animation language
- **Testable**: Animations visible and emotionally effective during Magic Phase scroll range

## Acceptance Criteria

- [x] **Floating Motion**: Segment 1 elements bob independently with gentle camera-like motion (different boats on water)
- [x] **Sparkler Animation**: "Magic" word reveals with scroll-triggered left-to-right sparkle sweep effect
- [x] **Color Transition**: "Magic" word appears white during sparkles, then fades to teal after animation completes
- [x] **Elegant Scaling**: Segment 1 scales subtly (0.98-1.0); Segment 2 scales dramatically (0.92-1.08) with rotation
- [x] **Energetic Slide-in**: Segment 2 slides in with momentum overshoot, then snaps sharply back to final position
- [x] **Smooth Interpolation**: All animations interpolate smoothly based on scroll progress via data-attributes
- [x] **Performance Optimized**: 60fps animations using CSS transforms with will-change hints
- [x] **Act-Specific Timing**: Animations active during 0-75% scroll range (covers all Act 1 segments)
- [x] **Sequential Timing**: Segment 2 waits until Segment 1 completes (no overlap)
- [x] **Bidirectional Animation**: Effects work correctly when scrolling backwards
- [x] **Smart Retrigger**: Sparkle animation only retriggers when fully faded out, not on partial scroll-ups
- [x] **Mobile Compatible**: Transform-only animations perform well on all devices

## Requirements

### Magic Phase Animation Language

- **REQ-INDEPENDENT-BOBBING**: Each Segment 1 element bobs independently with unique phase and frequency (boats on water effect)
- **REQ-SPARKLER-EFFECT**: Canvas-based particle sparkler sweeps left-to-right across "magic" word on scroll trigger
- **REQ-COLOR-CHOREOGRAPHY**: "Magic" word appears white during sparkle animation, then fades to brand teal
- **REQ-ELEGANT-SCALING**: Graceful scale transitions - Segment 1: subtle (0.98-1.0), Segment 2: dramatic (0.92-1.08)
- **REQ-ENERGETIC-ENTRANCE**: Segment 2 flies in with momentum overshoot, then snaps sharply into final position
- **REQ-ETHEREAL-FEEL**: Dreamy fog-emergence effect for Segment 1; energetic slide-in for Segment 2matic (0.92-1.08)
- **REQ-ETHEREAL-FEEL**: Dreamy fog-emergence effect for Segment 1; energetic slide-in for Segment 2

### Specific Animations

- **REQ-SEGMENT-1**: "Remember when AI coding felt like magic?"
  - Emerges from fog with slow power-curve fade-in
  - Each element (heading, subtext) bobs independently with different amplitude, phase, and frequency
  - Lower amplitude (4px) for "REMEMBER WHEN", higher (8px) for "AI coding..." headline
  - Horizontal bobbing component (30% of vertical) for natural motion
  - Bobbing amplitude fades in/out with element visibility to prevent jumps
  - Canvas-based sparkler particles sweep across "magic?" word triggered at 20% scroll progress
  - Sparkle sweep expands left-to-right (0-50% of animation), then contracts (50-100%)
  - Text reveals in sync with sparkle expansion using progressive clip-path
  - "Magic?" appears white during sparkles, fades to teal over 0.5s after sweep completes
  - Sparkler canvas fades in (5-20%), stays visible (20-45%), fades out (45-60%)
  - Individual timing per element via data-reveal-start/end attributes

- **REQ-SEGMENT-2**: "When shipping features was fast and exciting?"
  - Dramatic 400px slide in from left with easeOutBack momentum creating overshoot
  - Final snap back to position happens sharply for energetic feel
  - Rotation from -3deg to 0deg during entrance
  - Strong scale from 0.92 to 1.08 for punch
  - Fast opacity fade-in (reaches full at 10% segment progress)
  - "Fast" and "exciting" get brand teal color shift and glow intensity
  - Sequential timing - does not start until Segment 1 completes
  - Individual timing per element via data-reveal-start/end attributes

### Technical Implementation

- **REQ-CSS-TRANSFORMS**: Use hardware-accelerated CSS transforms (translateX, translateY, scale, rotate)
- **REQ-SCROLL-INTERPOLATION**: Animation progress based on scroll position within per-element data-reveal-start/end ranges
- **REQ-CANVAS-PARTICLES**: Hardware-accelerated canvas rendering for sparkler particle effects
- **REQ-CLIP-PATH-REVEAL**: Progressive text reveal using CSS clip-path synchronized with particle animation
- **REQ-SCROLL-TRIGGERED**: Sparkle animation triggers on scroll threshold crossing, not continuously scrubbed
- **REQ-SMART-RETRIGGER**: Sparkle only retriggers when text fully fades out (opacity = 0), not on partial scroll-ups
- **REQ-PERFORMANCE-OPTIMIZED**: Continuous requestAnimationFrame loop for bobbing; scroll-based for reveal/transitions
- **REQ-SEQUENTIAL-ENFORCEMENT**: Segment 2 timing set to start after Segment 1 ends (no overlap)

- **REQ-CSS-TRANSFORMS**: Use hardware-accelerated CSS transforms (translateX, translateY, scale, rotate)
- **REQ-SCROLL-INTERPOLATION**: Animation progress based on scroll position within per-element data-reveal-start/end ranges
- **REQ-MAGIC-WORD-EFFECTS**: Special effects for words with .magic-word and .speed-word classes
- **REQ-PERFORMANCE-OPTIMIZED**: Continuous requestAnimationFrame loop for floating; scroll-based for reveal/transitions
- **REQ-SEQUENTIAL-ENFORCEMENT**: Segment 2 timing set to start after Segment 1 ends (no overlap)

## Dependencies

- 026.02-BIZ-VIEWPORT-FIXED-OVERLAY (requires scroll-locked reveal system)

## Implementation Notes

### Animation System Architecture

```javascript
class MagicPhaseAnimator {
  constructor(progressiveReveal) {
    this.progressiveReveal = progressiveReveal;
    this.magicSegments = document.querySelectorAll('[data-act="1"]');
    this.bindAnimationUpdates();
  }

  bindAnimationUpdates() {
    // Hook into the progressive reveal system
    const originalUpdateVisibility =
      this.progressiveReveal.updateVisibility.bind(this.progressiveReveal);

    this.progressiveReveal.updateVisibility = (scrollProgress) => {
      originalUpdateVisibility(scrollProgress);
      this.updateMagicAnimations(scrollProgress);
    };
  }

  updateMagicAnimations(scrollProgress) {
    // Only animate during Magic Phase (0-20%)
    if (scrollProgress >= 0 && scrollProgress <= 20) {
      this.animateSegment1(scrollProgress);
      this.animateSegment2(scrollProgress);
    }
  }

  animateSegment1(scrollProgress) {
    const segment = document.querySelector('[data-segment="1"]');
    if (!segment.classList.contains('visible')) return;

    // Calculate animation progress within segment range (0-12%)
    const segmentProgress = this.mapToSegmentProgress(scrollProgress, 0, 12);

    // Gentle floating motion
    const floatY = Math.sin(Date.now() * 0.001) * 3; // 3px floating range
    const scaleProgress = this.easeOutQuart(segmentProgress);
    const scale = 0.8 + scaleProgress * 0.2; // 0.8 to 1.0

    segment.style.transform = `translateY(${floatY}px) scale(${scale})`;

    // Magic word glow effect
    const magicWord = segment.querySelector('.magic-word');
    if (magicWord) {
      const glowIntensity = 0.5 + Math.sin(Date.now() * 0.002) * 0.3;
      magicWord.style.textShadow = `0 0 ${glowIntensity * 20}px rgba(0, 255, 136, 0.6)`;
    }
  }

  animateSegment2(scrollProgress) {
    const segment = document.querySelector('[data-segment="2"]');
    if (!segment.classList.contains('visible')) return;

    // Calculate animation progress within segment range (8-20%)
    const segmentProgress = this.mapToSegmentProgress(scrollProgress, 8, 20);

    // Slide in from left with momentum
    const slideX = -40 * (1 - this.easeOutBack(segmentProgress));
    const scale = 0.9 + this.easeOutQuart(segmentProgress) * 0.1;

    segment.style.transform = `translateX(${slideX}px) scale(${scale})`;

    // Speed word energy effect
    const speedWord = segment.querySelector('.speed-word');
    if (speedWord) {
      const energyPulse = 1 + Math.sin(Date.now() * 0.003) * 0.1;
      speedWord.style.transform = `scale(${energyPulse})`;
      speedWord.style.color = `hsl(174, 100%, ${45 + energyPulse * 10}%)`;
    }
  }

  mapToSegmentProgress(scrollProgress, start, end) {
    return Math.max(0, Math.min(1, (scrollProgress - start) / (end - start)));
  }

  easeOutQuart(t) {
    return 1 - Math.pow(1 - t, 4);
  }

  easeOutBack(t) {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  }
}
```

### CSS Animation Foundation

```css
.narrative-segment[data-act='1'] {
  transition: opacity 0.4s ease-out;
  will-change: transform, opacity;
}

.magic-word {
  display: inline-block;
  transition: text-shadow 0.3s ease-out;
  will-change: text-shadow;
}

.speed-word {
  display: inline-block;
  transition:
    transform 0.2s ease-out,
    color 0.3s ease-out;
  will-change: transform, color;
}

/* Performance optimization */
.narrative-segment[data-act='1'] {
  backface-visibility: hidden;
  perspective: 1000;
}
```

### Animation Timing Strategy

- **Segment 1 (0-12% scroll)**:
  - Entry: Gentle scale from 0.8 to 1.0
  - Active: Continuous gentle floating motion
  - Magic word: Pulsing golden glow effect

- **Segment 2 (8-20% scroll)**:
  - Entry: Slide in from left (-40px to 0)
  - Active: Slight momentum-based scaling
  - Speed words: Energy pulse and color shift

### Performance Considerations

- Use `transform` instead of changing layout properties
- `will-change` declarations for GPU acceleration
- `backface-visibility: hidden` for optimization
- Efficient easing functions for smooth motion

### Success Criteria

- Each Segment 1 element bobs independently like different boats on water
- Sparkler particles sweep dramatically across "magic?" word when scrolling into view
- Text reveals progressively in sync with sparkle expansion
- Word appears white during animation, then smoothly transitions to teal
- Sparkle canvas fades in/out gracefully with overall narrative timing
- Scrolling up partially preserves animation state without retriggering
- Only fully scrolling out (opacity = 0) resets for fresh retrigger
- Smooth 60fps performance on all devices
- Animations respect scroll direction (bidirectional)
- Foundation ready for other act animations

This story establishes the cinematic animation system with sophisticated particle effects and creates the magical emotional tone for the narrative journey.

- Segments float gently with dreamy motion
- Magic words have warm, ethereal glow effects
- Animations feel magical and wonder-filled
- Smooth 60fps performance on all devices
- Animations respect scroll direction (bidirectional)
- Foundation ready for other act animations

This story establishes the cinematic animation system and creates the magical emotional tone for the narrative journey.
